/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/generate.sh.

/*
 * rs_for_each.rsh: Kernel Invocation Functions and Types
 *
 * The rsForEach() function can be used to invoke the root kernel of a script.
 *
 * The other functions are used to get the characteristics of the invocation of
 * an executing kernel, like dimensions and current indexes.  These functions take
 * a rs_kernel_context as argument.
 */

#ifndef RENDERSCRIPT_RS_FOR_EACH_RSH
#define RENDERSCRIPT_RS_FOR_EACH_RSH

/*
 * rs_for_each_strategy_t: Suggested cell processing order
 *
 * This type is used to suggest how the invoked kernel should iterate over the cells of the
 * allocations.  This is a hint only.  Implementations may not follow the suggestion.
 *
 * This specification can help the caching behavior of the running kernel, e.g. the cache
 * locality when the processing is distributed over multiple cores.
 */
typedef enum rs_for_each_strategy {
    RS_FOR_EACH_STRATEGY_SERIAL = 0, // Prefer contiguous memory regions.
    RS_FOR_EACH_STRATEGY_DONT_CARE = 1, // No prefrences.
    RS_FOR_EACH_STRATEGY_DST_LINEAR = 2, // Prefer DST.
    RS_FOR_EACH_STRATEGY_TILE_SMALL = 3, // Prefer processing small rectangular regions.
    RS_FOR_EACH_STRATEGY_TILE_MEDIUM = 4, // Prefer processing medium rectangular regions.
    RS_FOR_EACH_STRATEGY_TILE_LARGE = 5 // Prefer processing large rectangular regions.
} rs_for_each_strategy_t;

/*
 * rs_kernel_context: Handle to a kernel invocation context
 *
 * The kernel context contains common characteristics of the allocations being iterated
 * over, like dimensions, and rarely used indexes, like the Array0 index or the current
 * level of detail.
 *
 * A kernel may be executed in parallel over multiple threads.  Each thread will have its
 * own context.
 *
 * You can access the context by adding a special parameter named "context" and of type
 * rs_kernel_context to your kernel function.  See rsGetDimX() and rsGetArray0() for examples.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
typedef const struct rs_kernel_context_t * rs_kernel_context;
#endif

/*
 * rs_script_call_t: Cell iteration information
 *
 * This structure is used to provide iteration information to a rsForEach call.
 * It is currently used to restrict processing to a subset of cells.  In future
 * versions, it will also be used to provide hint on how to best iterate over
 * the cells.
 *
 * The Start fields are inclusive and the End fields are exclusive.  E.g. to iterate
 * over cells 4, 5, 6, and 7 in the X dimension, set xStart to 4 and xEnd to 8.
 */
typedef struct rs_script_call {
    rs_for_each_strategy_t strategy; // Currently ignored.  In the future, will be suggested cell iteration strategy.
    uint32_t xStart; // Starting index in the X dimension.
    uint32_t xEnd; // Ending index (exclusive) in the X dimension.
    uint32_t yStart; // Starting index in the Y dimension.
    uint32_t yEnd; // Ending index (exclusive) in the Y dimension.
    uint32_t zStart; // Starting index in the Z dimension.
    uint32_t zEnd; // Ending index (exclusive) in the Z dimension.
    uint32_t arrayStart; // Starting index in the Array0 dimension.
    uint32_t arrayEnd; // Ending index (exclusive) in the Array0 dimension.
    uint32_t array1Start; // Starting index in the Array1 dimension.
    uint32_t array1End; // Ending index (exclusive) in the Array1 dimension.
    uint32_t array2Start; // Starting index in the Array2 dimension.
    uint32_t array2End; // Ending index (exclusive) in the Array2 dimension.
    uint32_t array3Start; // Starting index in the Array3 dimension.
    uint32_t array3End; // Ending index (exclusive) in the Array3 dimension.
} rs_script_call_t;

/*
 * rsForEach: Invoke the root kernel of a script
 *
 * Invoke the kernel named "root" of the specified script.  Like other kernels, this root()
 * function will be invoked repeatedly over the cells of the specificed allocation, filling
 * the output allocation with the results.
 *
 * When rsForEach is called, the root script is launched immediately.  rsForEach returns
 * only when the script has completed and the output allocation is ready to use.
 *
 * The rs_script argument is typically initialized using a global variable set from Java.
 *
 * The kernel can be invoked with just an input allocation or just an output allocation.
 * This can be done by defining an rs_allocation variable and not initializing it.  E.g.
 * rs_script gCustomScript;
 * void specializedProcessing(rs_allocation in) {
 *   rs_allocation ignoredOut;
 *   rsForEach(gCustomScript, in, ignoredOut);
 * }
 *
 * If both input and output allocations are specified, they must have the same dimensions.
 *
 * Parameters:
 *   script: Script to call.
 *   input: Allocation to source data from.
 *   output: Allocation to write date into.
 *   usrData: User defined data to pass to the script.  May be NULL.
 *   sc: Extra control information used to select a sub-region of the allocation to be processed or suggest a walking strategy.  May be NULL.
 *   usrDataLen: Size of the userData structure.  This will be used to perform a shallow copy of the data if necessary.
 */
#if !defined(RS_VERSION) || (RS_VERSION <= 13)
extern void __attribute__((overloadable))
    rsForEach(rs_script script, rs_allocation input, rs_allocation output, const void* usrData,
              const rs_script_call_t* sc);
#endif

#if !defined(RS_VERSION) || (RS_VERSION <= 13)
extern void __attribute__((overloadable))
    rsForEach(rs_script script, rs_allocation input, rs_allocation output, const void* usrData);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 14) && (RS_VERSION <= 20))
extern void __attribute__((overloadable))
    rsForEach(rs_script script, rs_allocation input, rs_allocation output, const void* usrData,
              size_t usrDataLen, const rs_script_call_t* sc);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 14) && (RS_VERSION <= 20))
extern void __attribute__((overloadable))
    rsForEach(rs_script script, rs_allocation input, rs_allocation output, const void* usrData,
              size_t usrDataLen);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 14))
extern void __attribute__((overloadable))
    rsForEach(rs_script script, rs_allocation input, rs_allocation output);
#endif

/*
 * rsGetArray0: Index in the Array0 dimension for the specified context
 *
 * Returns the index in the Array0 dimension of the cell being processed, as specified
 * by the supplied context.
 *
 * This context is created when a kernel is launched and updated at each iteration.
 * It contains common characteristics of the allocations being iterated over and rarely
 * used indexes, like the Array0 index.
 *
 * You can access the context by adding a special parameter named "context" and of
 * type rs_kernel_context to your kernel function.  E.g.
 * short RS_KERNEL myKernel(short value, uint32_t x, rs_kernel_context context) {
 *   // The current index in the common x, y, z, w dimensions are accessed by
 *   // adding these variables as arguments.  For the more rarely used indexes
 *   // to the other dimensions, extract them from the context:
 *   uint32_t index_a0 = rsGetArray0(context);
 *   //...
 * }
 *
 * This function returns 0 if the Array0 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetArray0(rs_kernel_context context);
#endif

/*
 * rsGetArray1: Index in the Array1 dimension for the specified context
 *
 * Returns the index in the Array1 dimension of the cell being processed, as specified
 * by the supplied context.  See rsGetArray0() for an explanation of the context.
 *
 * Returns 0 if the Array1 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetArray1(rs_kernel_context context);
#endif

/*
 * rsGetArray2: Index in the Array2 dimension for the specified context
 *
 * Returns the index in the Array2 dimension of the cell being processed,
 * as specified by the supplied context.  See rsGetArray0() for an explanation
 * of the context.
 *
 * Returns 0 if the Array2 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetArray2(rs_kernel_context context);
#endif

/*
 * rsGetArray3: Index in the Array3 dimension for the specified context
 *
 * Returns the index in the Array3 dimension of the cell being processed, as specified
 * by the supplied context.  See rsGetArray0() for an explanation of the context.
 *
 * Returns 0 if the Array3 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetArray3(rs_kernel_context context);
#endif

/*
 * rsGetDimArray0: Size of the Array0 dimension for the specified context
 *
 * Returns the size of the Array0 dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Array0 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimArray0(rs_kernel_context context);
#endif

/*
 * rsGetDimArray1: Size of the Array1 dimension for the specified context
 *
 * Returns the size of the Array1 dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Array1 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimArray1(rs_kernel_context context);
#endif

/*
 * rsGetDimArray2: Size of the Array2 dimension for the specified context
 *
 * Returns the size of the Array2 dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Array2 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimArray2(rs_kernel_context context);
#endif

/*
 * rsGetDimArray3: Size of the Array3 dimension for the specified context
 *
 * Returns the size of the Array3 dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Array3 dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimArray3(rs_kernel_context context);
#endif

/*
 * rsGetDimHasFaces: Presence of more than one face for the specified context
 *
 * If the context refers to a cubemap, this function returns true if there's more than
 * one face present.  In all other cases, it returns false.  See rsGetDimX() for an
 * explanation of the context.
 *
 * rsAllocationGetDimFaces() is similar but returns 0 or 1 instead of a bool.
 *
 * Returns: Returns true if more than one face is present, false otherwise.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern bool __attribute__((overloadable))
    rsGetDimHasFaces(rs_kernel_context context);
#endif

/*
 * rsGetDimLod: Number of levels of detail for the specified context
 *
 * Returns the number of levels of detail for the specified context.  This is useful
 * for mipmaps.  See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if Level of Detail is not used.
 *
 * rsAllocationGetDimLOD() is similar but returns 0 or 1 instead the actual
 * number of levels.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimLod(rs_kernel_context context);
#endif

/*
 * rsGetDimX: Size of the X dimension for the specified context
 *
 * Returns the size of the X dimension for the specified context.
 *
 * This context is created when a kernel is launched.  It contains common
 * characteristics of the allocations being iterated over by the kernel in
 * a very efficient structure.  It also contains rarely used indexes.
 *
 * You can access it by adding a special parameter named "context" and of
 * type rs_kernel_context to your kernel function.  E.g.
 * int4 RS_KERNEL myKernel(int4 value, rs_kernel_context context) {
 *   uint32_t size = rsGetDimX(context); //...
 *
 * To get the dimension of specific allocation, use rsAllocationGetDimX().
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimX(rs_kernel_context context);
#endif

/*
 * rsGetDimY: Size of the Y dimension for the specified context
 *
 * Returns the size of the X dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Y dimension is not present.
 *
 * To get the dimension of specific allocation, use rsAllocationGetDimY().
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimY(rs_kernel_context context);
#endif

/*
 * rsGetDimZ: Size of the Z dimension for the specified context
 *
 * Returns the size of the Z dimension for the specified context.
 * See rsGetDimX() for an explanation of the context.
 *
 * Returns 0 if the Z dimension is not present.
 *
 * To get the dimension of specific allocation, use rsAllocationGetDimZ().
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetDimZ(rs_kernel_context context);
#endif

/*
 * rsGetFace: Coordinate of the Face for the specified context
 *
 * Returns the face on which the cell being processed is found, as specified by the
 * supplied context.  See rsGetArray0() for an explanation of the context.
 *
 * Returns RS_ALLOCATION_CUBEMAP_FACE_POSITIVE_X if the face dimension is not
 * present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern rs_allocation_cubemap_face __attribute__((overloadable))
    rsGetFace(rs_kernel_context context);
#endif

/*
 * rsGetLod: Index in the Levels of Detail dimension for the specified context
 *
 * Returns the index in the Levels of Detail dimension of the cell being processed,
 * as specified by the supplied context.  See rsGetArray0() for an explanation of
 * the context.
 *
 * Returns 0 if the Levels of Detail dimension is not present.
 */
#if (defined(RS_VERSION) && (RS_VERSION >= 23))
extern uint32_t __attribute__((overloadable))
    rsGetLod(rs_kernel_context context);
#endif

#endif // RENDERSCRIPT_RS_FOR_EACH_RSH
