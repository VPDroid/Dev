page.title=Looper
page.customHeadTag=<link rel="stylesheet" type="text/css" href="doxygen-dac.css">
@jd:body
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Looper</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:looper_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="looper_8h.html">looper.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadb10521a80138b777ba1bc2ca74d4af5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a></td></tr>
<tr class="separator:gadb10521a80138b777ba1bc2ca74d4af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410b184b4e48302c439e36c8ce0a7a89"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#ga410b184b4e48302c439e36c8ce0a7a89">ALooper_callbackFunc</a> )(int fd, int events, void *data)</td></tr>
<tr class="separator:ga410b184b4e48302c439e36c8ce0a7a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf9bdc3014f3d54c426b6d2df10de4960"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group___looper.html#ggaf9bdc3014f3d54c426b6d2df10de4960a1fff26ab5859b0308b58a3f8d58ef1eb">ALOOPER_PREPARE_ALLOW_NON_CALLBACKS</a> = 1&lt;&lt;0
 }</td></tr>
<tr class="separator:gaf9bdc3014f3d54c426b6d2df10de4960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb49720dc49f7d4e4cf9adbf2948e409"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group___looper.html#ggadb49720dc49f7d4e4cf9adbf2948e409a55528f1b28df17cc4b6317cc0d0fde47">ALOOPER_POLL_WAKE</a> = -1, 
<a class="el" href="group___looper.html#ggadb49720dc49f7d4e4cf9adbf2948e409a64fe936780bfd9927affaf8e8cc81cc2">ALOOPER_POLL_CALLBACK</a> = -2, 
<a class="el" href="group___looper.html#ggadb49720dc49f7d4e4cf9adbf2948e409a3fe4eec66dff78a9fa8afca02e8b8443">ALOOPER_POLL_TIMEOUT</a> = -3, 
<a class="el" href="group___looper.html#ggadb49720dc49f7d4e4cf9adbf2948e409af8ebd4022f6f5d5fea864f6999b7e6b4">ALOOPER_POLL_ERROR</a> = -4
 }</td></tr>
<tr class="separator:gadb49720dc49f7d4e4cf9adbf2948e409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae05225933a42f81e7c4a9fb286596f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="group___looper.html#ggaae05225933a42f81e7c4a9fb286596f9ae3d18f8dd1faf6f34468df10667949bc">ALOOPER_EVENT_INPUT</a> = 1 &lt;&lt; 0, 
<a class="el" href="group___looper.html#ggaae05225933a42f81e7c4a9fb286596f9a71273fd07e009057e6e3475d10f8286d">ALOOPER_EVENT_OUTPUT</a> = 1 &lt;&lt; 1, 
<a class="el" href="group___looper.html#ggaae05225933a42f81e7c4a9fb286596f9a14016d8f39373b8ce061276a957960f6">ALOOPER_EVENT_ERROR</a> = 1 &lt;&lt; 2, 
<a class="el" href="group___looper.html#ggaae05225933a42f81e7c4a9fb286596f9a5e7fb5acdecef18b2c293f6309e5d4ab">ALOOPER_EVENT_HANGUP</a> = 1 &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="group___looper.html#ggaae05225933a42f81e7c4a9fb286596f9aefe82c6ce8e02d13aceaebdec15c2aff">ALOOPER_EVENT_INVALID</a> = 1 &lt;&lt; 4
<br/>
 }</td></tr>
<tr class="separator:gaae05225933a42f81e7c4a9fb286596f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga741ccd90a0eb9209c6bddf2326d89e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#ga741ccd90a0eb9209c6bddf2326d89e4a">ALooper_forThread</a> ()</td></tr>
<tr class="separator:ga741ccd90a0eb9209c6bddf2326d89e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a070b904dd957cc65af9eb5ef6dfa25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#ga1a070b904dd957cc65af9eb5ef6dfa25">ALooper_prepare</a> (int opts)</td></tr>
<tr class="separator:ga1a070b904dd957cc65af9eb5ef6dfa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ad7ac48ab01a34bfd25840c92ff07b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gae1ad7ac48ab01a34bfd25840c92ff07b">ALooper_acquire</a> (<a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *looper)</td></tr>
<tr class="separator:gae1ad7ac48ab01a34bfd25840c92ff07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab723c3c2ac2c66bc695913a194073727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gab723c3c2ac2c66bc695913a194073727">ALooper_release</a> (<a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *looper)</td></tr>
<tr class="separator:gab723c3c2ac2c66bc695913a194073727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9044602b76fef7f47c7e11a801561c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce</a> (int timeoutMillis, int *outFd, int *outEvents, void **outData)</td></tr>
<tr class="separator:ga2a9044602b76fef7f47c7e11a801561c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7cd0636edc4ed227aadc585360ebefa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll</a> (int timeoutMillis, int *outFd, int *outEvents, void **outData)</td></tr>
<tr class="separator:gaa7cd0636edc4ed227aadc585360ebefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2585652f8ae2e2444979194ebe32aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gab2585652f8ae2e2444979194ebe32aaf">ALooper_wake</a> (<a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *looper)</td></tr>
<tr class="separator:gab2585652f8ae2e2444979194ebe32aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2668285bfadcf21ef4d371568a30be33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#ga2668285bfadcf21ef4d371568a30be33">ALooper_addFd</a> (<a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *looper, int fd, int ident, int events, <a class="el" href="group___looper.html#ga410b184b4e48302c439e36c8ce0a7a89">ALooper_callbackFunc</a> callback, void *data)</td></tr>
<tr class="separator:ga2668285bfadcf21ef4d371568a30be33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d68ed05698b251489b4f6c8e54daad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___looper.html#gaf7d68ed05698b251489b4f6c8e54daad">ALooper_removeFd</a> (<a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *looper, int fd)</td></tr>
<tr class="separator:gaf7d68ed05698b251489b4f6c8e54daad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gadb10521a80138b777ba1bc2ca74d4af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> <a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ALooper</p>
<p>A looper is the state tracking an event loop for a thread. Loopers do not define event structures or other such things; rather they are a lower-level facility to attach one or more discrete objects listening for an event. An "event" here is simply data available on a file descriptor: each attached object has an associated file descriptor, and waiting for "events" means (internally) polling on all of these file descriptors until one or more of them have data available.</p>
<p>A thread can have only one ALooper associated with it. </p>

</div>
</div>
<a class="anchor" id="ga410b184b4e48302c439e36c8ce0a7a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* ALooper_callbackFunc)(int fd, int events, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For callback-based event loops, this is the prototype of the function that is called when a file descriptor event occurs. It is given the file descriptor it is associated with, a bitmask of the poll events that were triggered (typically ALOOPER_EVENT_INPUT), and the data pointer that was originally supplied.</p>
<p>Implementations should return 1 to continue receiving callbacks, or 0 to have this file descriptor and callback unregistered from the looper. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf9bdc3014f3d54c426b6d2df10de4960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Option for for <a class="el" href="group___looper.html#ga1a070b904dd957cc65af9eb5ef6dfa25">ALooper_prepare()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf9bdc3014f3d54c426b6d2df10de4960a1fff26ab5859b0308b58a3f8d58ef1eb"></a>ALOOPER_PREPARE_ALLOW_NON_CALLBACKS</em>&#160;</td><td class="fielddoc">
<p>This looper will accept calls to <a class="el" href="group___looper.html#ga2668285bfadcf21ef4d371568a30be33">ALooper_addFd()</a> that do not have a callback (that is provide NULL for the callback). In this case the caller of <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a> or <a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll()</a> MUST check the return from these functions to discover when data is available on such fds and process it. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadb49720dc49f7d4e4cf9adbf2948e409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Result from <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a> and <a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggadb49720dc49f7d4e4cf9adbf2948e409a55528f1b28df17cc4b6317cc0d0fde47"></a>ALOOPER_POLL_WAKE</em>&#160;</td><td class="fielddoc">
<p>The poll was awoken using wake() before the timeout expired and no callbacks were executed and no other file descriptors were ready. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggadb49720dc49f7d4e4cf9adbf2948e409a64fe936780bfd9927affaf8e8cc81cc2"></a>ALOOPER_POLL_CALLBACK</em>&#160;</td><td class="fielddoc">
<p>Result from <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a> and <a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll()</a>: One or more callbacks were executed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggadb49720dc49f7d4e4cf9adbf2948e409a3fe4eec66dff78a9fa8afca02e8b8443"></a>ALOOPER_POLL_TIMEOUT</em>&#160;</td><td class="fielddoc">
<p>Result from <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a> and <a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll()</a>: The timeout expired. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggadb49720dc49f7d4e4cf9adbf2948e409af8ebd4022f6f5d5fea864f6999b7e6b4"></a>ALOOPER_POLL_ERROR</em>&#160;</td><td class="fielddoc">
<p>Result from <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a> and <a class="el" href="group___looper.html#gaa7cd0636edc4ed227aadc585360ebefa">ALooper_pollAll()</a>: An error occurred. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaae05225933a42f81e7c4a9fb286596f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for file descriptor events that a looper can monitor.</p>
<p>These flag bits can be combined to monitor multiple events at once. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaae05225933a42f81e7c4a9fb286596f9ae3d18f8dd1faf6f34468df10667949bc"></a>ALOOPER_EVENT_INPUT</em>&#160;</td><td class="fielddoc">
<p>The file descriptor is available for read operations. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaae05225933a42f81e7c4a9fb286596f9a71273fd07e009057e6e3475d10f8286d"></a>ALOOPER_EVENT_OUTPUT</em>&#160;</td><td class="fielddoc">
<p>The file descriptor is available for write operations. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaae05225933a42f81e7c4a9fb286596f9a14016d8f39373b8ce061276a957960f6"></a>ALOOPER_EVENT_ERROR</em>&#160;</td><td class="fielddoc">
<p>The file descriptor has encountered an error condition.</p>
<p>The looper always sends notifications about errors; it is not necessary to specify this event flag in the requested event set. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaae05225933a42f81e7c4a9fb286596f9a5e7fb5acdecef18b2c293f6309e5d4ab"></a>ALOOPER_EVENT_HANGUP</em>&#160;</td><td class="fielddoc">
<p>The file descriptor was hung up. For example, indicates that the remote end of a pipe or socket was closed.</p>
<p>The looper always sends notifications about hangups; it is not necessary to specify this event flag in the requested event set. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaae05225933a42f81e7c4a9fb286596f9aefe82c6ce8e02d13aceaebdec15c2aff"></a>ALOOPER_EVENT_INVALID</em>&#160;</td><td class="fielddoc">
<p>The file descriptor is invalid. For example, the file descriptor was closed prematurely.</p>
<p>The looper always sends notifications about invalid file descriptors; it is not necessary to specify this event flag in the requested event set. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae1ad7ac48ab01a34bfd25840c92ff07b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALooper_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td>
          <td class="paramname"><em>looper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire a reference on the given ALooper object. This prevents the object from being deleted until the reference is removed. This is only needed to safely hand an ALooper from one thread to another. </p>

</div>
</div>
<a class="anchor" id="ga2668285bfadcf21ef4d371568a30be33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALooper_addFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td>
          <td class="paramname"><em>looper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___looper.html#ga410b184b4e48302c439e36c8ce0a7a89">ALooper_callbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new file descriptor to be polled by the looper. If the same file descriptor was previously added, it is replaced.</p>
<p>"fd" is the file descriptor to be added. "ident" is an identifier for this event, which is returned from <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a>. The identifier must be &gt;= 0, or ALOOPER_POLL_CALLBACK if providing a non-NULL callback. "events" are the poll events to wake up on. Typically this is ALOOPER_EVENT_INPUT. "callback" is the function to call when there is an event on the file descriptor. "data" is a private data pointer to supply to the callback.</p>
<p>There are two main uses of this function:</p>
<p>(1) If "callback" is non-NULL, then this function will be called when there is data on the file descriptor. It should execute any events it has pending, appropriately reading from the file descriptor. The 'ident' is ignored in this case.</p>
<p>(2) If "callback" is NULL, the 'ident' will be returned by ALooper_pollOnce when its file descriptor has data available, requiring the caller to take care of processing it.</p>
<p>Returns 1 if the file descriptor was added or -1 if an error occurred.</p>
<p>This method can be called on any thread. This method may block briefly if it needs to wake the poll. </p>

</div>
</div>
<a class="anchor" id="ga741ccd90a0eb9209c6bddf2326d89e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a>* ALooper_forThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the looper associated with the calling thread, or NULL if there is not one. </p>

</div>
</div>
<a class="anchor" id="gaa7cd0636edc4ed227aadc585360ebefa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALooper_pollAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMillis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>outData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="group___looper.html#ga2a9044602b76fef7f47c7e11a801561c">ALooper_pollOnce()</a>, but performs all pending callbacks until all data has been consumed or a file descriptor is available with no callback. This function will never return ALOOPER_POLL_CALLBACK. </p>

</div>
</div>
<a class="anchor" id="ga2a9044602b76fef7f47c7e11a801561c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALooper_pollOnce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMillis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>outData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for events to be available, with optional timeout in milliseconds. Invokes callbacks for all file descriptors on which an event occurred.</p>
<p>If the timeout is zero, returns immediately without blocking. If the timeout is negative, waits indefinitely until an event appears.</p>
<p>Returns ALOOPER_POLL_WAKE if the poll was awoken using wake() before the timeout expired and no callbacks were invoked and no other file descriptors were ready.</p>
<p>Returns ALOOPER_POLL_CALLBACK if one or more callbacks were invoked.</p>
<p>Returns ALOOPER_POLL_TIMEOUT if there was no data before the given timeout expired.</p>
<p>Returns ALOOPER_POLL_ERROR if an error occurred.</p>
<p>Returns a value &gt;= 0 containing an identifier (the same identifier <code>ident</code> passed to <a class="el" href="group___looper.html#ga2668285bfadcf21ef4d371568a30be33">ALooper_addFd()</a>) if its file descriptor has data and it has no callback function (requiring the caller here to handle it). In this (and only this) case outFd, outEvents and outData will contain the poll events and data associated with the fd, otherwise they will be set to NULL.</p>
<p>This method does not return until it has finished invoking the appropriate callbacks for all file descriptors that were signalled. </p>

</div>
</div>
<a class="anchor" id="ga1a070b904dd957cc65af9eb5ef6dfa25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a>* ALooper_prepare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares a looper associated with the calling thread, and returns it. If the thread already has a looper, it is returned. Otherwise, a new one is created, associated with the thread, and returned.</p>
<p>The opts may be ALOOPER_PREPARE_ALLOW_NON_CALLBACKS or 0. </p>

</div>
</div>
<a class="anchor" id="gab723c3c2ac2c66bc695913a194073727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALooper_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td>
          <td class="paramname"><em>looper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a reference that was previously acquired with <a class="el" href="group___looper.html#gae1ad7ac48ab01a34bfd25840c92ff07b">ALooper_acquire()</a>. </p>

</div>
</div>
<a class="anchor" id="gaf7d68ed05698b251489b4f6c8e54daad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALooper_removeFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td>
          <td class="paramname"><em>looper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a previously added file descriptor from the looper.</p>
<p>When this method returns, it is safe to close the file descriptor since the looper will no longer have a reference to it. However, it is possible for the callback to already be running or for it to run one last time if the file descriptor was already signalled. Calling code is responsible for ensuring that this case is safely handled. For example, if the callback takes care of removing itself during its own execution either by returning 0 or by calling this method, then it can be guaranteed to not be invoked again at any later time unless registered anew.</p>
<p>Returns 1 if the file descriptor was removed, 0 if none was previously registered or -1 if an error occurred.</p>
<p>This method can be called on any thread. This method may block briefly if it needs to wake the poll. </p>

</div>
</div>
<a class="anchor" id="gab2585652f8ae2e2444979194ebe32aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALooper_wake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___looper.html#gadb10521a80138b777ba1bc2ca74d4af5">ALooper</a> *&#160;</td>
          <td class="paramname"><em>looper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes the poll asynchronously.</p>
<p>This method can be called on any thread. This method returns immediately. </p>

</div>
</div>
</div><!-- contents -->
